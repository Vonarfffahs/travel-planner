
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CalculationResult` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model CalculationResult
 * 
 */
export type CalculationResultModel = runtime.Types.Result.DefaultSelection<Prisma.$CalculationResultPayload>

export type AggregateCalculationResult = {
  _count: CalculationResultCountAggregateOutputType | null
  _avg: CalculationResultAvgAggregateOutputType | null
  _sum: CalculationResultSumAggregateOutputType | null
  _min: CalculationResultMinAggregateOutputType | null
  _max: CalculationResultMaxAggregateOutputType | null
}

export type CalculationResultAvgAggregateOutputType = {
  id: number | null
  nodeCount: number | null
  costLimit: number | null
  timeLimit: number | null
  alpha: number | null
  beta: number | null
  iterations: number | null
  antsCount: number | null
  totalValue: number | null
  executionTime: number | null
  userId: number | null
}

export type CalculationResultSumAggregateOutputType = {
  id: number | null
  nodeCount: number | null
  costLimit: number | null
  timeLimit: number | null
  alpha: number | null
  beta: number | null
  iterations: number | null
  antsCount: number | null
  totalValue: number | null
  executionTime: number | null
  userId: number | null
}

export type CalculationResultMinAggregateOutputType = {
  id: number | null
  algorithmType: string | null
  nodeCount: number | null
  costLimit: number | null
  timeLimit: number | null
  alpha: number | null
  beta: number | null
  iterations: number | null
  antsCount: number | null
  totalValue: number | null
  executionTime: number | null
  createdAt: Date | null
  userId: number | null
}

export type CalculationResultMaxAggregateOutputType = {
  id: number | null
  algorithmType: string | null
  nodeCount: number | null
  costLimit: number | null
  timeLimit: number | null
  alpha: number | null
  beta: number | null
  iterations: number | null
  antsCount: number | null
  totalValue: number | null
  executionTime: number | null
  createdAt: Date | null
  userId: number | null
}

export type CalculationResultCountAggregateOutputType = {
  id: number
  algorithmType: number
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha: number
  beta: number
  iterations: number
  antsCount: number
  totalValue: number
  executionTime: number
  route: number
  createdAt: number
  userId: number
  _all: number
}


export type CalculationResultAvgAggregateInputType = {
  id?: true
  nodeCount?: true
  costLimit?: true
  timeLimit?: true
  alpha?: true
  beta?: true
  iterations?: true
  antsCount?: true
  totalValue?: true
  executionTime?: true
  userId?: true
}

export type CalculationResultSumAggregateInputType = {
  id?: true
  nodeCount?: true
  costLimit?: true
  timeLimit?: true
  alpha?: true
  beta?: true
  iterations?: true
  antsCount?: true
  totalValue?: true
  executionTime?: true
  userId?: true
}

export type CalculationResultMinAggregateInputType = {
  id?: true
  algorithmType?: true
  nodeCount?: true
  costLimit?: true
  timeLimit?: true
  alpha?: true
  beta?: true
  iterations?: true
  antsCount?: true
  totalValue?: true
  executionTime?: true
  createdAt?: true
  userId?: true
}

export type CalculationResultMaxAggregateInputType = {
  id?: true
  algorithmType?: true
  nodeCount?: true
  costLimit?: true
  timeLimit?: true
  alpha?: true
  beta?: true
  iterations?: true
  antsCount?: true
  totalValue?: true
  executionTime?: true
  createdAt?: true
  userId?: true
}

export type CalculationResultCountAggregateInputType = {
  id?: true
  algorithmType?: true
  nodeCount?: true
  costLimit?: true
  timeLimit?: true
  alpha?: true
  beta?: true
  iterations?: true
  antsCount?: true
  totalValue?: true
  executionTime?: true
  route?: true
  createdAt?: true
  userId?: true
  _all?: true
}

export type CalculationResultAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CalculationResult to aggregate.
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CalculationResults to fetch.
   */
  orderBy?: Prisma.CalculationResultOrderByWithRelationInput | Prisma.CalculationResultOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CalculationResultWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CalculationResults from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CalculationResults.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CalculationResults
  **/
  _count?: true | CalculationResultCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: CalculationResultAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: CalculationResultSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CalculationResultMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CalculationResultMaxAggregateInputType
}

export type GetCalculationResultAggregateType<T extends CalculationResultAggregateArgs> = {
      [P in keyof T & keyof AggregateCalculationResult]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCalculationResult[P]>
    : Prisma.GetScalarType<T[P], AggregateCalculationResult[P]>
}




export type CalculationResultGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CalculationResultWhereInput
  orderBy?: Prisma.CalculationResultOrderByWithAggregationInput | Prisma.CalculationResultOrderByWithAggregationInput[]
  by: Prisma.CalculationResultScalarFieldEnum[] | Prisma.CalculationResultScalarFieldEnum
  having?: Prisma.CalculationResultScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CalculationResultCountAggregateInputType | true
  _avg?: CalculationResultAvgAggregateInputType
  _sum?: CalculationResultSumAggregateInputType
  _min?: CalculationResultMinAggregateInputType
  _max?: CalculationResultMaxAggregateInputType
}

export type CalculationResultGroupByOutputType = {
  id: number
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha: number | null
  beta: number | null
  iterations: number | null
  antsCount: number | null
  totalValue: number
  executionTime: number
  route: runtime.JsonValue
  createdAt: Date
  userId: number | null
  _count: CalculationResultCountAggregateOutputType | null
  _avg: CalculationResultAvgAggregateOutputType | null
  _sum: CalculationResultSumAggregateOutputType | null
  _min: CalculationResultMinAggregateOutputType | null
  _max: CalculationResultMaxAggregateOutputType | null
}

type GetCalculationResultGroupByPayload<T extends CalculationResultGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CalculationResultGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CalculationResultGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CalculationResultGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CalculationResultGroupByOutputType[P]>
      }
    >
  >



export type CalculationResultWhereInput = {
  AND?: Prisma.CalculationResultWhereInput | Prisma.CalculationResultWhereInput[]
  OR?: Prisma.CalculationResultWhereInput[]
  NOT?: Prisma.CalculationResultWhereInput | Prisma.CalculationResultWhereInput[]
  id?: Prisma.IntFilter<"CalculationResult"> | number
  algorithmType?: Prisma.StringFilter<"CalculationResult"> | string
  nodeCount?: Prisma.IntFilter<"CalculationResult"> | number
  costLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  timeLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  alpha?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  beta?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  iterations?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  antsCount?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  totalValue?: Prisma.FloatFilter<"CalculationResult"> | number
  executionTime?: Prisma.FloatFilter<"CalculationResult"> | number
  route?: Prisma.JsonFilter<"CalculationResult">
  createdAt?: Prisma.DateTimeFilter<"CalculationResult"> | Date | string
  userId?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}

export type CalculationResultOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  algorithmType?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrderInput | Prisma.SortOrder
  beta?: Prisma.SortOrderInput | Prisma.SortOrder
  iterations?: Prisma.SortOrderInput | Prisma.SortOrder
  antsCount?: Prisma.SortOrderInput | Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  route?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
}

export type CalculationResultWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.CalculationResultWhereInput | Prisma.CalculationResultWhereInput[]
  OR?: Prisma.CalculationResultWhereInput[]
  NOT?: Prisma.CalculationResultWhereInput | Prisma.CalculationResultWhereInput[]
  algorithmType?: Prisma.StringFilter<"CalculationResult"> | string
  nodeCount?: Prisma.IntFilter<"CalculationResult"> | number
  costLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  timeLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  alpha?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  beta?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  iterations?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  antsCount?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  totalValue?: Prisma.FloatFilter<"CalculationResult"> | number
  executionTime?: Prisma.FloatFilter<"CalculationResult"> | number
  route?: Prisma.JsonFilter<"CalculationResult">
  createdAt?: Prisma.DateTimeFilter<"CalculationResult"> | Date | string
  userId?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}, "id">

export type CalculationResultOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  algorithmType?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrderInput | Prisma.SortOrder
  beta?: Prisma.SortOrderInput | Prisma.SortOrder
  iterations?: Prisma.SortOrderInput | Prisma.SortOrder
  antsCount?: Prisma.SortOrderInput | Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  route?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.CalculationResultCountOrderByAggregateInput
  _avg?: Prisma.CalculationResultAvgOrderByAggregateInput
  _max?: Prisma.CalculationResultMaxOrderByAggregateInput
  _min?: Prisma.CalculationResultMinOrderByAggregateInput
  _sum?: Prisma.CalculationResultSumOrderByAggregateInput
}

export type CalculationResultScalarWhereWithAggregatesInput = {
  AND?: Prisma.CalculationResultScalarWhereWithAggregatesInput | Prisma.CalculationResultScalarWhereWithAggregatesInput[]
  OR?: Prisma.CalculationResultScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CalculationResultScalarWhereWithAggregatesInput | Prisma.CalculationResultScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"CalculationResult"> | number
  algorithmType?: Prisma.StringWithAggregatesFilter<"CalculationResult"> | string
  nodeCount?: Prisma.IntWithAggregatesFilter<"CalculationResult"> | number
  costLimit?: Prisma.FloatWithAggregatesFilter<"CalculationResult"> | number
  timeLimit?: Prisma.FloatWithAggregatesFilter<"CalculationResult"> | number
  alpha?: Prisma.FloatNullableWithAggregatesFilter<"CalculationResult"> | number | null
  beta?: Prisma.FloatNullableWithAggregatesFilter<"CalculationResult"> | number | null
  iterations?: Prisma.IntNullableWithAggregatesFilter<"CalculationResult"> | number | null
  antsCount?: Prisma.IntNullableWithAggregatesFilter<"CalculationResult"> | number | null
  totalValue?: Prisma.FloatWithAggregatesFilter<"CalculationResult"> | number
  executionTime?: Prisma.FloatWithAggregatesFilter<"CalculationResult"> | number
  route?: Prisma.JsonWithAggregatesFilter<"CalculationResult">
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"CalculationResult"> | Date | string
  userId?: Prisma.IntNullableWithAggregatesFilter<"CalculationResult"> | number | null
}

export type CalculationResultCreateInput = {
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  user?: Prisma.UserCreateNestedOneWithoutCalculationsInput
}

export type CalculationResultUncheckedCreateInput = {
  id?: number
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  userId?: number | null
}

export type CalculationResultUpdateInput = {
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneWithoutCalculationsNestedInput
}

export type CalculationResultUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type CalculationResultCreateManyInput = {
  id?: number
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  userId?: number | null
}

export type CalculationResultUpdateManyMutationInput = {
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CalculationResultUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type CalculationResultListRelationFilter = {
  every?: Prisma.CalculationResultWhereInput
  some?: Prisma.CalculationResultWhereInput
  none?: Prisma.CalculationResultWhereInput
}

export type CalculationResultOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CalculationResultCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  algorithmType?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrder
  beta?: Prisma.SortOrder
  iterations?: Prisma.SortOrder
  antsCount?: Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  route?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CalculationResultAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrder
  beta?: Prisma.SortOrder
  iterations?: Prisma.SortOrder
  antsCount?: Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CalculationResultMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  algorithmType?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrder
  beta?: Prisma.SortOrder
  iterations?: Prisma.SortOrder
  antsCount?: Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CalculationResultMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  algorithmType?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrder
  beta?: Prisma.SortOrder
  iterations?: Prisma.SortOrder
  antsCount?: Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CalculationResultSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  nodeCount?: Prisma.SortOrder
  costLimit?: Prisma.SortOrder
  timeLimit?: Prisma.SortOrder
  alpha?: Prisma.SortOrder
  beta?: Prisma.SortOrder
  iterations?: Prisma.SortOrder
  antsCount?: Prisma.SortOrder
  totalValue?: Prisma.SortOrder
  executionTime?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CalculationResultCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput> | Prisma.CalculationResultCreateWithoutUserInput[] | Prisma.CalculationResultUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CalculationResultCreateOrConnectWithoutUserInput | Prisma.CalculationResultCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CalculationResultCreateManyUserInputEnvelope
  connect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
}

export type CalculationResultUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput> | Prisma.CalculationResultCreateWithoutUserInput[] | Prisma.CalculationResultUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CalculationResultCreateOrConnectWithoutUserInput | Prisma.CalculationResultCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CalculationResultCreateManyUserInputEnvelope
  connect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
}

export type CalculationResultUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput> | Prisma.CalculationResultCreateWithoutUserInput[] | Prisma.CalculationResultUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CalculationResultCreateOrConnectWithoutUserInput | Prisma.CalculationResultCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CalculationResultUpsertWithWhereUniqueWithoutUserInput | Prisma.CalculationResultUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CalculationResultCreateManyUserInputEnvelope
  set?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  disconnect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  delete?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  connect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  update?: Prisma.CalculationResultUpdateWithWhereUniqueWithoutUserInput | Prisma.CalculationResultUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CalculationResultUpdateManyWithWhereWithoutUserInput | Prisma.CalculationResultUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CalculationResultScalarWhereInput | Prisma.CalculationResultScalarWhereInput[]
}

export type CalculationResultUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput> | Prisma.CalculationResultCreateWithoutUserInput[] | Prisma.CalculationResultUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CalculationResultCreateOrConnectWithoutUserInput | Prisma.CalculationResultCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CalculationResultUpsertWithWhereUniqueWithoutUserInput | Prisma.CalculationResultUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CalculationResultCreateManyUserInputEnvelope
  set?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  disconnect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  delete?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  connect?: Prisma.CalculationResultWhereUniqueInput | Prisma.CalculationResultWhereUniqueInput[]
  update?: Prisma.CalculationResultUpdateWithWhereUniqueWithoutUserInput | Prisma.CalculationResultUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CalculationResultUpdateManyWithWhereWithoutUserInput | Prisma.CalculationResultUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CalculationResultScalarWhereInput | Prisma.CalculationResultScalarWhereInput[]
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type CalculationResultCreateWithoutUserInput = {
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type CalculationResultUncheckedCreateWithoutUserInput = {
  id?: number
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type CalculationResultCreateOrConnectWithoutUserInput = {
  where: Prisma.CalculationResultWhereUniqueInput
  create: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput>
}

export type CalculationResultCreateManyUserInputEnvelope = {
  data: Prisma.CalculationResultCreateManyUserInput | Prisma.CalculationResultCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type CalculationResultUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.CalculationResultWhereUniqueInput
  update: Prisma.XOR<Prisma.CalculationResultUpdateWithoutUserInput, Prisma.CalculationResultUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.CalculationResultCreateWithoutUserInput, Prisma.CalculationResultUncheckedCreateWithoutUserInput>
}

export type CalculationResultUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.CalculationResultWhereUniqueInput
  data: Prisma.XOR<Prisma.CalculationResultUpdateWithoutUserInput, Prisma.CalculationResultUncheckedUpdateWithoutUserInput>
}

export type CalculationResultUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.CalculationResultScalarWhereInput
  data: Prisma.XOR<Prisma.CalculationResultUpdateManyMutationInput, Prisma.CalculationResultUncheckedUpdateManyWithoutUserInput>
}

export type CalculationResultScalarWhereInput = {
  AND?: Prisma.CalculationResultScalarWhereInput | Prisma.CalculationResultScalarWhereInput[]
  OR?: Prisma.CalculationResultScalarWhereInput[]
  NOT?: Prisma.CalculationResultScalarWhereInput | Prisma.CalculationResultScalarWhereInput[]
  id?: Prisma.IntFilter<"CalculationResult"> | number
  algorithmType?: Prisma.StringFilter<"CalculationResult"> | string
  nodeCount?: Prisma.IntFilter<"CalculationResult"> | number
  costLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  timeLimit?: Prisma.FloatFilter<"CalculationResult"> | number
  alpha?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  beta?: Prisma.FloatNullableFilter<"CalculationResult"> | number | null
  iterations?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  antsCount?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
  totalValue?: Prisma.FloatFilter<"CalculationResult"> | number
  executionTime?: Prisma.FloatFilter<"CalculationResult"> | number
  route?: Prisma.JsonFilter<"CalculationResult">
  createdAt?: Prisma.DateTimeFilter<"CalculationResult"> | Date | string
  userId?: Prisma.IntNullableFilter<"CalculationResult"> | number | null
}

export type CalculationResultCreateManyUserInput = {
  id?: number
  algorithmType: string
  nodeCount: number
  costLimit: number
  timeLimit: number
  alpha?: number | null
  beta?: number | null
  iterations?: number | null
  antsCount?: number | null
  totalValue: number
  executionTime: number
  route: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
}

export type CalculationResultUpdateWithoutUserInput = {
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CalculationResultUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CalculationResultUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  algorithmType?: Prisma.StringFieldUpdateOperationsInput | string
  nodeCount?: Prisma.IntFieldUpdateOperationsInput | number
  costLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  timeLimit?: Prisma.FloatFieldUpdateOperationsInput | number
  alpha?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  beta?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  iterations?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  antsCount?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  totalValue?: Prisma.FloatFieldUpdateOperationsInput | number
  executionTime?: Prisma.FloatFieldUpdateOperationsInput | number
  route?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type CalculationResultSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  algorithmType?: boolean
  nodeCount?: boolean
  costLimit?: boolean
  timeLimit?: boolean
  alpha?: boolean
  beta?: boolean
  iterations?: boolean
  antsCount?: boolean
  totalValue?: boolean
  executionTime?: boolean
  route?: boolean
  createdAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}, ExtArgs["result"]["calculationResult"]>

export type CalculationResultSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  algorithmType?: boolean
  nodeCount?: boolean
  costLimit?: boolean
  timeLimit?: boolean
  alpha?: boolean
  beta?: boolean
  iterations?: boolean
  antsCount?: boolean
  totalValue?: boolean
  executionTime?: boolean
  route?: boolean
  createdAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}, ExtArgs["result"]["calculationResult"]>

export type CalculationResultSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  algorithmType?: boolean
  nodeCount?: boolean
  costLimit?: boolean
  timeLimit?: boolean
  alpha?: boolean
  beta?: boolean
  iterations?: boolean
  antsCount?: boolean
  totalValue?: boolean
  executionTime?: boolean
  route?: boolean
  createdAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}, ExtArgs["result"]["calculationResult"]>

export type CalculationResultSelectScalar = {
  id?: boolean
  algorithmType?: boolean
  nodeCount?: boolean
  costLimit?: boolean
  timeLimit?: boolean
  alpha?: boolean
  beta?: boolean
  iterations?: boolean
  antsCount?: boolean
  totalValue?: boolean
  executionTime?: boolean
  route?: boolean
  createdAt?: boolean
  userId?: boolean
}

export type CalculationResultOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "algorithmType" | "nodeCount" | "costLimit" | "timeLimit" | "alpha" | "beta" | "iterations" | "antsCount" | "totalValue" | "executionTime" | "route" | "createdAt" | "userId", ExtArgs["result"]["calculationResult"]>
export type CalculationResultInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}
export type CalculationResultIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}
export type CalculationResultIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.CalculationResult$userArgs<ExtArgs>
}

export type $CalculationResultPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CalculationResult"
  objects: {
    user: Prisma.$UserPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    algorithmType: string
    nodeCount: number
    costLimit: number
    timeLimit: number
    alpha: number | null
    beta: number | null
    iterations: number | null
    antsCount: number | null
    totalValue: number
    executionTime: number
    route: runtime.JsonValue
    createdAt: Date
    userId: number | null
  }, ExtArgs["result"]["calculationResult"]>
  composites: {}
}

export type CalculationResultGetPayload<S extends boolean | null | undefined | CalculationResultDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload, S>

export type CalculationResultCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CalculationResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CalculationResultCountAggregateInputType | true
  }

export interface CalculationResultDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalculationResult'], meta: { name: 'CalculationResult' } }
  /**
   * Find zero or one CalculationResult that matches the filter.
   * @param {CalculationResultFindUniqueArgs} args - Arguments to find a CalculationResult
   * @example
   * // Get one CalculationResult
   * const calculationResult = await prisma.calculationResult.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CalculationResultFindUniqueArgs>(args: Prisma.SelectSubset<T, CalculationResultFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CalculationResult that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CalculationResultFindUniqueOrThrowArgs} args - Arguments to find a CalculationResult
   * @example
   * // Get one CalculationResult
   * const calculationResult = await prisma.calculationResult.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CalculationResultFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CalculationResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CalculationResult that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultFindFirstArgs} args - Arguments to find a CalculationResult
   * @example
   * // Get one CalculationResult
   * const calculationResult = await prisma.calculationResult.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CalculationResultFindFirstArgs>(args?: Prisma.SelectSubset<T, CalculationResultFindFirstArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CalculationResult that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultFindFirstOrThrowArgs} args - Arguments to find a CalculationResult
   * @example
   * // Get one CalculationResult
   * const calculationResult = await prisma.calculationResult.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CalculationResultFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CalculationResultFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CalculationResults that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CalculationResults
   * const calculationResults = await prisma.calculationResult.findMany()
   * 
   * // Get first 10 CalculationResults
   * const calculationResults = await prisma.calculationResult.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const calculationResultWithIdOnly = await prisma.calculationResult.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CalculationResultFindManyArgs>(args?: Prisma.SelectSubset<T, CalculationResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CalculationResult.
   * @param {CalculationResultCreateArgs} args - Arguments to create a CalculationResult.
   * @example
   * // Create one CalculationResult
   * const CalculationResult = await prisma.calculationResult.create({
   *   data: {
   *     // ... data to create a CalculationResult
   *   }
   * })
   * 
   */
  create<T extends CalculationResultCreateArgs>(args: Prisma.SelectSubset<T, CalculationResultCreateArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CalculationResults.
   * @param {CalculationResultCreateManyArgs} args - Arguments to create many CalculationResults.
   * @example
   * // Create many CalculationResults
   * const calculationResult = await prisma.calculationResult.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CalculationResultCreateManyArgs>(args?: Prisma.SelectSubset<T, CalculationResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many CalculationResults and returns the data saved in the database.
   * @param {CalculationResultCreateManyAndReturnArgs} args - Arguments to create many CalculationResults.
   * @example
   * // Create many CalculationResults
   * const calculationResult = await prisma.calculationResult.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many CalculationResults and only return the `id`
   * const calculationResultWithIdOnly = await prisma.calculationResult.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CalculationResultCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CalculationResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a CalculationResult.
   * @param {CalculationResultDeleteArgs} args - Arguments to delete one CalculationResult.
   * @example
   * // Delete one CalculationResult
   * const CalculationResult = await prisma.calculationResult.delete({
   *   where: {
   *     // ... filter to delete one CalculationResult
   *   }
   * })
   * 
   */
  delete<T extends CalculationResultDeleteArgs>(args: Prisma.SelectSubset<T, CalculationResultDeleteArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CalculationResult.
   * @param {CalculationResultUpdateArgs} args - Arguments to update one CalculationResult.
   * @example
   * // Update one CalculationResult
   * const calculationResult = await prisma.calculationResult.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CalculationResultUpdateArgs>(args: Prisma.SelectSubset<T, CalculationResultUpdateArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CalculationResults.
   * @param {CalculationResultDeleteManyArgs} args - Arguments to filter CalculationResults to delete.
   * @example
   * // Delete a few CalculationResults
   * const { count } = await prisma.calculationResult.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CalculationResultDeleteManyArgs>(args?: Prisma.SelectSubset<T, CalculationResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CalculationResults.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CalculationResults
   * const calculationResult = await prisma.calculationResult.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CalculationResultUpdateManyArgs>(args: Prisma.SelectSubset<T, CalculationResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CalculationResults and returns the data updated in the database.
   * @param {CalculationResultUpdateManyAndReturnArgs} args - Arguments to update many CalculationResults.
   * @example
   * // Update many CalculationResults
   * const calculationResult = await prisma.calculationResult.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more CalculationResults and only return the `id`
   * const calculationResultWithIdOnly = await prisma.calculationResult.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CalculationResultUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CalculationResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one CalculationResult.
   * @param {CalculationResultUpsertArgs} args - Arguments to update or create a CalculationResult.
   * @example
   * // Update or create a CalculationResult
   * const calculationResult = await prisma.calculationResult.upsert({
   *   create: {
   *     // ... data to create a CalculationResult
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CalculationResult we want to update
   *   }
   * })
   */
  upsert<T extends CalculationResultUpsertArgs>(args: Prisma.SelectSubset<T, CalculationResultUpsertArgs<ExtArgs>>): Prisma.Prisma__CalculationResultClient<runtime.Types.Result.GetResult<Prisma.$CalculationResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CalculationResults.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultCountArgs} args - Arguments to filter CalculationResults to count.
   * @example
   * // Count the number of CalculationResults
   * const count = await prisma.calculationResult.count({
   *   where: {
   *     // ... the filter for the CalculationResults we want to count
   *   }
   * })
  **/
  count<T extends CalculationResultCountArgs>(
    args?: Prisma.Subset<T, CalculationResultCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CalculationResultCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CalculationResult.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CalculationResultAggregateArgs>(args: Prisma.Subset<T, CalculationResultAggregateArgs>): Prisma.PrismaPromise<GetCalculationResultAggregateType<T>>

  /**
   * Group by CalculationResult.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CalculationResultGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CalculationResultGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CalculationResultGroupByArgs['orderBy'] }
      : { orderBy?: CalculationResultGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CalculationResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalculationResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CalculationResult model
 */
readonly fields: CalculationResultFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CalculationResult.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CalculationResultClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.CalculationResult$userArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CalculationResult$userArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CalculationResult model
 */
export interface CalculationResultFieldRefs {
  readonly id: Prisma.FieldRef<"CalculationResult", 'Int'>
  readonly algorithmType: Prisma.FieldRef<"CalculationResult", 'String'>
  readonly nodeCount: Prisma.FieldRef<"CalculationResult", 'Int'>
  readonly costLimit: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly timeLimit: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly alpha: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly beta: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly iterations: Prisma.FieldRef<"CalculationResult", 'Int'>
  readonly antsCount: Prisma.FieldRef<"CalculationResult", 'Int'>
  readonly totalValue: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly executionTime: Prisma.FieldRef<"CalculationResult", 'Float'>
  readonly route: Prisma.FieldRef<"CalculationResult", 'Json'>
  readonly createdAt: Prisma.FieldRef<"CalculationResult", 'DateTime'>
  readonly userId: Prisma.FieldRef<"CalculationResult", 'Int'>
}
    

// Custom InputTypes
/**
 * CalculationResult findUnique
 */
export type CalculationResultFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter, which CalculationResult to fetch.
   */
  where: Prisma.CalculationResultWhereUniqueInput
}

/**
 * CalculationResult findUniqueOrThrow
 */
export type CalculationResultFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter, which CalculationResult to fetch.
   */
  where: Prisma.CalculationResultWhereUniqueInput
}

/**
 * CalculationResult findFirst
 */
export type CalculationResultFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter, which CalculationResult to fetch.
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CalculationResults to fetch.
   */
  orderBy?: Prisma.CalculationResultOrderByWithRelationInput | Prisma.CalculationResultOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CalculationResults.
   */
  cursor?: Prisma.CalculationResultWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CalculationResults from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CalculationResults.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CalculationResults.
   */
  distinct?: Prisma.CalculationResultScalarFieldEnum | Prisma.CalculationResultScalarFieldEnum[]
}

/**
 * CalculationResult findFirstOrThrow
 */
export type CalculationResultFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter, which CalculationResult to fetch.
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CalculationResults to fetch.
   */
  orderBy?: Prisma.CalculationResultOrderByWithRelationInput | Prisma.CalculationResultOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CalculationResults.
   */
  cursor?: Prisma.CalculationResultWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CalculationResults from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CalculationResults.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CalculationResults.
   */
  distinct?: Prisma.CalculationResultScalarFieldEnum | Prisma.CalculationResultScalarFieldEnum[]
}

/**
 * CalculationResult findMany
 */
export type CalculationResultFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter, which CalculationResults to fetch.
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CalculationResults to fetch.
   */
  orderBy?: Prisma.CalculationResultOrderByWithRelationInput | Prisma.CalculationResultOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CalculationResults.
   */
  cursor?: Prisma.CalculationResultWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CalculationResults from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CalculationResults.
   */
  skip?: number
  distinct?: Prisma.CalculationResultScalarFieldEnum | Prisma.CalculationResultScalarFieldEnum[]
}

/**
 * CalculationResult create
 */
export type CalculationResultCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * The data needed to create a CalculationResult.
   */
  data: Prisma.XOR<Prisma.CalculationResultCreateInput, Prisma.CalculationResultUncheckedCreateInput>
}

/**
 * CalculationResult createMany
 */
export type CalculationResultCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CalculationResults.
   */
  data: Prisma.CalculationResultCreateManyInput | Prisma.CalculationResultCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CalculationResult createManyAndReturn
 */
export type CalculationResultCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * The data used to create many CalculationResults.
   */
  data: Prisma.CalculationResultCreateManyInput | Prisma.CalculationResultCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * CalculationResult update
 */
export type CalculationResultUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * The data needed to update a CalculationResult.
   */
  data: Prisma.XOR<Prisma.CalculationResultUpdateInput, Prisma.CalculationResultUncheckedUpdateInput>
  /**
   * Choose, which CalculationResult to update.
   */
  where: Prisma.CalculationResultWhereUniqueInput
}

/**
 * CalculationResult updateMany
 */
export type CalculationResultUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CalculationResults.
   */
  data: Prisma.XOR<Prisma.CalculationResultUpdateManyMutationInput, Prisma.CalculationResultUncheckedUpdateManyInput>
  /**
   * Filter which CalculationResults to update
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * Limit how many CalculationResults to update.
   */
  limit?: number
}

/**
 * CalculationResult updateManyAndReturn
 */
export type CalculationResultUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * The data used to update CalculationResults.
   */
  data: Prisma.XOR<Prisma.CalculationResultUpdateManyMutationInput, Prisma.CalculationResultUncheckedUpdateManyInput>
  /**
   * Filter which CalculationResults to update
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * Limit how many CalculationResults to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * CalculationResult upsert
 */
export type CalculationResultUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * The filter to search for the CalculationResult to update in case it exists.
   */
  where: Prisma.CalculationResultWhereUniqueInput
  /**
   * In case the CalculationResult found by the `where` argument doesn't exist, create a new CalculationResult with this data.
   */
  create: Prisma.XOR<Prisma.CalculationResultCreateInput, Prisma.CalculationResultUncheckedCreateInput>
  /**
   * In case the CalculationResult was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CalculationResultUpdateInput, Prisma.CalculationResultUncheckedUpdateInput>
}

/**
 * CalculationResult delete
 */
export type CalculationResultDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
  /**
   * Filter which CalculationResult to delete.
   */
  where: Prisma.CalculationResultWhereUniqueInput
}

/**
 * CalculationResult deleteMany
 */
export type CalculationResultDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CalculationResults to delete
   */
  where?: Prisma.CalculationResultWhereInput
  /**
   * Limit how many CalculationResults to delete.
   */
  limit?: number
}

/**
 * CalculationResult.user
 */
export type CalculationResult$userArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * CalculationResult without action
 */
export type CalculationResultDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CalculationResult
   */
  select?: Prisma.CalculationResultSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CalculationResult
   */
  omit?: Prisma.CalculationResultOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CalculationResultInclude<ExtArgs> | null
}
